<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      :root{--bg:#0b1220;--panel:#0f1724;--accent:#00e676;--muted:#9aa4b2}
      html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021 0%, #0b1220 100%);color:#e6eef6;font-family: 'Segoe UI', Roboto, system-ui, -apple-system, "Helvetica Neue", Arial}
      canvas{display:block;width:100%;height:100vh}
      /* Left side HUD */
      .leftPanel{position:fixed;left:16px;top:16px;width:220px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 6px 18px rgba(2,6,23,0.6);z-index:70}
      .leftPanel h4{margin:0 0 8px 0;font-size:14px;color:var(--accent)}
      .leftPanel .label{font-size:12px;color:var(--muted);margin-bottom:6px}
      .leftPanel .value{font-weight:700;font-size:20px;margin-bottom:6px}
      .leader{margin-top:10px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;display:none}
      .leader h5{margin:0 0 6px 0;font-size:13px;color:#ffd;}
      .leader ol{list-style:none;margin:0;padding:0}
      .leader li{display:flex;align-items:center;gap:8px;font-size:13px;padding:6px 4px;border-bottom:1px dashed rgba(255,255,255,0.02)}
      .leader .rank{width:22px;height:22px;border-radius:6px;display:inline-flex;align-items:center;justify-content:center;font-weight:800}
      .leader .rank.r1{background:#ff5252;color:#111}
      .leader .rank.r2{background:#ff8a50;color:#111}
      .leader .rank.r3{background:#ffd54f;color:#111}
      /* Start panel (center) */
      .startPanel{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:360px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(2,6,23,0.6);z-index:90}
      .startPanel input{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;margin-bottom:8px}
      .startPanel button{width:100%;padding:8px;border-radius:8px;border:none;background:var(--accent);color:#022;font-weight:700}
      .instruction{font-size:13px;color:var(--muted);margin-top:8px}
      .hidden{display:none}
      /* slow tip */
      .slowTip{position:fixed;left:50%;top:18px;transform:translateX(-50%);background:rgba(0,0,0,0.72);padding:10px 14px;border-radius:10px;color:var(--accent);font-weight:800;font-size:16px;z-index:9999;animation:blink 0.6s ease-in-out infinite;box-shadow:0 6px 18px rgba(0,0,0,0.6);pointer-events:none}
      @keyframes blink{0%{opacity:1}50%{opacity:0.15}100%{opacity:1}}
      .controls{position:fixed;left:0;right:0;bottom:12px;padding:10px 12px;display:flex;gap:12px;justify-content:center;align-items:flex-end;z-index:30}
      .btn{width:84px;height:84px;border-radius:18px;background:var(--panel);border:1px solid rgba(255,255,255,0.03);color:#fff;font-size:18px;display:flex;align-items:center;justify-content:center;touch-action:none}
      .btn.pressed{background:var(--accent);color:#022}
      .btn.wide{width:140px}
    </style>
    <style>
      /* Cheat button positioned top-right to avoid covering left HUD */
      #cheatBtn{ position:fixed; right:16px; top:12px; z-index:120; padding:6px 10px; border-radius:8px; background:#222; color:#ffd600; border:none; display:none; box-shadow:0 6px 16px rgba(0,0,0,0.5); }
      /* Responsive adjustments for top controls on small screens */
      @media (max-width:720px){
        #topControls{ right:12px !important; left:auto !important; top:12px !important; gap:8px; align-items:center; }
        #topControls .status{ display:none; }
        #btnAutoFire, #btnPausePlay{ padding:6px 8px !important; font-size:13px !important; min-width:64px !important; }
      }
    </style>
  </head>
  <body>
    <div class="leftPanel" id="leftPanel">
      <div class="label">Player</div>
      <div class="value" id="playerNameDisplay">Player: —</div>
      <div class="label" style="margin-top:6px">UID</div>
      <div class="value" id="uid" style="font-size:12px;padding-top:0">—</div>
      <div class="label">Score</div>
      <div class="value" id="scoreDisplay">0</div>
      <div class="label">Missed</div>
      <div class="value" id="missDisplaySmall">0/10</div>
      <div class="leader">
        <h5>Leaderboard</h5>
        <ol id="leaderboard" style="margin:0;padding-left:16px"></ol>
      </div>
    </div>

    <!-- Firebase debug panel (helps diagnose auth / Firestore issues) -->
    <div id="fbDebug" style="position:fixed;right:16px;bottom:16px;background:rgba(0,0,0,0.7);color:#fff;padding:10px 12px;border-radius:10px;font-size:13px;z-index:120;max-width:320px;box-shadow:0 6px 18px rgba(0,0,0,0.6)">FB: initializing...</div>

    <div class="startPanel" id="startPanel">
      <input id="playerNameInput" placeholder="Enter player name" maxlength="18" />
      <button id="btnStart">Start</button>
      <div class="instruction">Green = +1pts · Red = -5pts <br> Leaving red = +10pts+5s slow time</div>
      <!-- Start-screen leaderboard (shows top 5 before starting) -->
      <div id="startLeaderboard" style="margin-top:12px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;">
        <div style="font-size:13px;color:var(--muted);margin-bottom:6px;font-weight:700">Top Players</div>
        <ol id="startLeaderboardList" style="margin:0;padding-left:16px;font-size:13px;color:var(--muted)"></ol>
      </div>
        <div style="margin-top:10px;display:flex;justify-content:space-between;align-items:center">
          <a href="#" id="creditsLink" style="color:var(--muted);font-size:13px;text-decoration:underline">Credits</a>
          <div style="font-size:12px;color:var(--muted)">v1.0</div>
        </div>
    </div>

    <div id="topControls" style="position:fixed;right:16px;top:12px;z-index:260;display:flex;gap:12px;align-items:center;">
      <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
      <button id="btnTools" style="padding:8px 10px;border-radius:8px;background:#222;color:#ffd600;border:none">Tools</button>
    </div>
    <canvas id="game"></canvas>
    <!-- HUD canvas sits above controls so player is visible over buttons; pointer-events:none lets touches go through -->
    <canvas id="hud" style="position:fixed;left:0;top:0;width:100%;height:100vh;z-index:40;pointer-events:none"></canvas>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <!-- Firebase (modular) initialization & helpers -->
    <script type="module">
      // Firebase modular SDK via CDN
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
      import { getAuth, signInAnonymously, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';
      import { getFirestore, doc, getDoc, setDoc, collection, query, orderBy, limit, getDocs } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

      const firebaseConfig = {
        apiKey: "AIzaSyANg0NbgehLNhHDNBV4buxRwlbvmxx4LoA",
        authDomain: "blastergamekmrxz.firebaseapp.com",
        projectId: "blastergamekmrxz",
        storageBucket: "blastergamekmrxz.firebasestorage.app",
        messagingSenderId: "349787225298",
        appId: "1:349787225298:web:d5e8de4ec304d47580810b",
        measurementId: "G-ES9Q1KR0T0"
      };

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);

      // simple in-page debug helper
      function fbDebug(msg, level='info'){
        try{
          const el = document.getElementById('fbDebug');
          if (el) el.textContent = 'FB: ' + msg;
        }catch(e){}
        if (level === 'error') console.error('[FBDEBUG]', msg); else if (level === 'warn') console.warn('[FBDEBUG]', msg); else console.log('[FBDEBUG]', msg);
      }

      // show basic firebase config & origin (masked apiKey) for quick diagnosis
      function fbShowConfig(){
        try{
          const el = document.getElementById('fbDebug');
          if (!el) return;
          const maskedKey = (firebaseConfig && firebaseConfig.apiKey) ? (firebaseConfig.apiKey.slice(0,6) + '...' + firebaseConfig.apiKey.slice(-4)) : 'n/a';
          const text = `proj:${firebaseConfig.projectId || 'n/a'} • origin:${location.origin} • key:${maskedKey}`;
          el.textContent = 'FB: ' + text;
          console.log('[FBDEBUG] config:', { projectId: firebaseConfig.projectId, origin: location.origin });
        }catch(e){}
      }

      async function initFirebase(){
        fbDebug('initializing...');
        try{
          await signInAnonymously(auth);
          fbDebug('anonymous sign-in requested');
        }catch(e){ console.error('Anonymous sign-in failed', e); fbDebug('anonymous sign-in failed: '+(e && e.message), 'error'); }

        onAuthStateChanged(auth, user => {
          // store user globally as required
          window._fbUser = user || null;
          fbDebug(user ? ('signed in: ' + user.uid) : 'signed out');
          // update UID displays immediately when auth state changes
          try{
            const uidEl = document.getElementById('uid');
            if (uidEl) uidEl.textContent = user ? user.uid : 'not signed in';
          }catch(e){ console.error('Error updating UID elements', e); }
          console.log('Firebase auth state changed, user=', user && user.uid);
          window.dispatchEvent(new CustomEvent('fbAuthChanged'));
          // attempt to update UI immediately if updateScore is available
          try{ if (window.updateScore) window.updateScore(); }catch(e){}
          // load per-user state when auth changes
          if (user){
            loadUserState().then(data => {
              fbDebug('user state loaded');
              try{ if (window.updateScore) window.updateScore(); }catch(e){}
            }).catch(err => { console.warn('loadUserState failed', err); fbDebug('loadUserState failed: '+(err && err.message),'warn'); });
          }
        });

        // initial leaderboard load
        try{
          const results = await loadTopScores();
          fbDebug('leaderboard loaded: ' + (results && results.length ? results.length : 0) + ' entries');
        }catch(e){ console.warn('loadTopScores failed', e); fbDebug('loadTopScores failed: '+(e && e.message),'warn'); }
        // if UI populate function exists, call it after initial load
        try{ if (window.populateLeaderboard) window.populateLeaderboard(); }catch(e){}
        // also show config & origin in debug panel to help diagnose GitHub Pages origin issues
        try{ fbShowConfig(); }catch(e){}
      }

      async function saveScoreToFirestore(name, score){
        // prefer to write to the session-specific leaderboard id if present, otherwise fall back to auth uid
        const docId = window._currentEntryId || (window._fbUser && window._fbUser.uid);
        if (!docId){ console.warn('No doc id or auth available for leaderboard save'); fbDebug('saveScore: no target id','warn'); return; }
        const ref = doc(db, 'leaderboard', docId);
        try{
          // include authenticated UID in the document body (not just the doc ID)
          const authUidForSave = (window._fbUser && window._fbUser.uid) ? window._fbUser.uid : docId;
          await setDoc(ref, { uid: authUidForSave, name: name || 'Player', score: Number(score)||0, ts: Date.now() }, { merge: true });
          fbDebug('score updated for ' + (name||'Player') + ' : ' + score);
          try{ await loadTopScores(); fbDebug('leaderboard refreshed after save'); }catch(e){}
        }catch(e){ console.error('saveScoreToFirestore failed', e); fbDebug('saveScore failed: '+(e && e.message),'error'); }
      }

      // user state (usedCheats etc) stored separately in `users/{uid}` so we can update without touching leaderboard rules
      async function saveUserState(payload){
        if (!window._fbUser) { console.warn('Not authenticated yet'); fbDebug('saveUserState: auth missing','warn'); return; }
        const uid = window._fbUser.uid;
        const ref = doc(db, 'users', uid);
        try{
          await setDoc(ref, Object.assign({ uid, ts: Date.now() }, payload || {}), { merge: true });
          fbDebug('user state saved');
          return true;
        }catch(e){ console.error('saveUserState failed', e); fbDebug('saveUserState failed: '+(e && e.message),'error'); return false; }
      }

      async function loadUserState(){
        if (!window._fbUser) return null;
        const uid = window._fbUser.uid;
        const ref = doc(db, 'users', uid);
        try{
          const snap = await getDoc(ref);
          if (snap.exists()){ window._fbUserState = snap.data(); window.dispatchEvent(new CustomEvent('fbUserStateUpdated')); return snap.data(); }
          window._fbUserState = null; window.dispatchEvent(new CustomEvent('fbUserStateUpdated')); return null;
        }catch(e){ console.error('loadUserState failed', e); window._fbUserState = null; window.dispatchEvent(new CustomEvent('fbUserStateUpdated')); return null; }
      }

      async function loadTopScores(){
        try{
          const col = collection(db, 'leaderboard');
          const q = query(col, orderBy('score','desc'), limit(10));
          const snaps = await getDocs(q);
          const results = [];
          snaps.forEach(s => results.push(s.data()));
          window._fbLeaderboard = results;
          window.dispatchEvent(new CustomEvent('fbLeaderboardUpdated'));
          fbDebug('loaded top scores (' + results.length + ')');
          return results;
        }catch(e){ console.error('loadTopScores failed', e); window._fbLeaderboard = []; window.dispatchEvent(new CustomEvent('fbLeaderboardUpdated')); return []; }
      }

      // expose minimal API to global scope for the main script to use
      window.initFirebase = initFirebase;
      window.saveScoreToFirestore = saveScoreToFirestore;
      window.loadTopScores = loadTopScores;
      window.saveUserState = saveUserState;
      window.loadUserState = loadUserState;
      // helper to force a fresh anonymous user (sign out then sign in) — resolves with the new user or null
      async function refreshAnonUser(options){
        // options: { attempts: number, perAttemptTimeout: ms, backoffMs: number }
        const opts = Object.assign({ attempts: 3, perAttemptTimeout: 8000, backoffMs: 1200 }, (options||{}));
        try{ if (auth.currentUser) await signOut(auth); }catch(e){ console.warn('signOut failed', e); }

        for (let attempt = 1; attempt <= opts.attempts; attempt++){
          fbDebug(`anonymous sign-in attempt ${attempt}/${opts.attempts}...`);
          try{ const uidEl = document.getElementById('uid'); if (uidEl) uidEl.textContent = `signing in (attempt ${attempt}/${opts.attempts})...`; }catch(e){}

          // Wait for auth state change or the per-attempt timeout
          const user = await new Promise(async (resolve) => {
            let settled = false;
            const unsub = onAuthStateChanged(auth, u => {
              if (u && !settled){ settled = true; try{ unsub(); }catch(e){} resolve(u); }
            });
            const to = setTimeout(()=>{
              if (!settled){ settled = true; try{ unsub(); }catch(e){} resolve(null); }
            }, opts.perAttemptTimeout);
            try{ await signInAnonymously(auth); }catch(e){ if (!settled){ settled = true; try{ unsub(); }catch(_){} clearTimeout(to); console.warn('Anonymous sign-in threw', e); resolve(null); } }
          });

          if (user){
            // got a user
            window._fbUser = user;
            fbDebug('signed in: ' + user.uid);
            try{ const uidEl = document.getElementById('uid'); if (uidEl) uidEl.textContent = user.uid; }catch(e){}
            window.dispatchEvent(new CustomEvent('fbAuthChanged'));
            try{ if (window.updateScore) window.updateScore(); }catch(e){}
            return user;
          }

          // attempt failed, show message and backoff before retrying
          fbDebug(`attempt ${attempt} failed (will retry)`,'warn');
          try{ const uidEl = document.getElementById('uid'); if (uidEl) uidEl.textContent = 'signing in...'; }catch(e){}
          if (attempt < opts.attempts) await new Promise(r => setTimeout(r, opts.backoffMs * attempt));
        }

        // all attempts failed
        fbDebug('anonymous sign-in failed after retries','error');
        try{ const uidEl = document.getElementById('uid'); if (uidEl) uidEl.textContent = 'sign-in failed'; }catch(e){}
        return null;
      }
      window.refreshAnonUser = refreshAnonUser;

      // auto-init
      initFirebase();
    </script>

    <script>
      // Controls setup
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');
      const controls = { left:false, right:false, action:false };
      // runtime toggles
      let paused = false;
      let autoFire = false;
      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }
      function bindButton(el, key){
        const start = ev => { ev.preventDefault(); // when autoFire is on, don't toggle action state via the button
          if (!(key === 'action' && autoFire)) controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        const end = ev => { ev.preventDefault(); if (!(key === 'action' && autoFire)) controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false}); el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start); el.addEventListener('mouseup', end); el.addEventListener('mouseleave', end);
      }
      bindButton(leftBtn,'left'); bindButton(rightBtn,'right'); bindButton(actionBtn,'action');
      window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });
      window.gameControls = { isDown: k => !!controls[k], onStart: fn => window.addEventListener('controlstart', e => fn(e.detail.key)), onEnd: fn => window.addEventListener('controlend', e => fn(e.detail.key)) };
      updateStatus();

      // Simple demo game using controls
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      let w = canvas.width = innerWidth;
      let h = canvas.height = innerHeight;
      window.addEventListener('resize', ()=>{ w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

      let score = 0;
      let missed = 0; // count green particles that reached the floor
      const missedLimit = 10;
      // speed factor increases over time so particles fall faster
      let speedFactor = 1;
      setInterval(()=>{ if (!paused && !gameOver && started) speedFactor += 0.06; }, 8000);
      // game start / player
      let started = false;
      let playerName = '';
      // slow-motion timer (ms since epoch until which slow motion applies)
      let slowUntil = 0;
      // applySlow now *adds* time to the existing slow window when already active
      function applySlow(seconds){
        const now = Date.now();
        if (slowUntil && slowUntil > now){
          slowUntil += (seconds * 1000);
        } else {
          slowUntil = now + (seconds * 1000);
        }
        const remaining = Math.ceil((slowUntil - now) / 1000);
        showSlowTip(remaining);
      }
      function getEffectiveSpeedFactor(){ return (Date.now() < slowUntil) ? Math.max(0.2, speedFactor * 0.35) : speedFactor; }

      // spawn scaling: start with low spawn chance and increase with speed
      const spawnBase = 0.006;
      function getSpawnChance(){ return Math.min(0.08, spawnBase + (speedFactor - 1) * 0.01); }

      // audio (use local Sounds folder)
      const coinSound = new Audio('Sounds/coin.mp3'); coinSound.preload = 'auto';
      const blastSound = new Audio('Sounds/blast.wav'); blastSound.preload = 'auto';

      // shatter/effects for hits
      const effects = [];
      function createShatter(x,y,color){
        const count = 12;
        for (let i=0;i<count;i++){
          const ang = Math.random() * Math.PI * 2;
          const speed = 1 + Math.random() * 3;
          effects.push({ x: x, y: y, vx: Math.cos(ang) * speed, vy: Math.sin(ang) * speed - 1, life: 600 + Math.random()*400, born: Date.now(), color });
        }
      }
      function updateAndDrawEffects(dt){
        for (let i = effects.length -1; i >=0; i--){
          const p = effects[i];
          const age = Date.now() - p.born;
          if (age > p.life){ effects.splice(i,1); continue; }
          // simple physics
          p.vy += 0.12; // gravity
          p.x += p.vx * (dt/16);
          p.y += p.vy * (dt/16);
          const a = 1 - (age / p.life);
          ctx.globalAlpha = a;
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, 3, 3);
          ctx.globalAlpha = 1;
        }
      }

      // slow tip UI
      let slowTipTimer = null;
      function showSlowTip(seconds){
        // remove existing
        const existing = document.getElementById('slowTip');
        if (existing) existing.remove();
        const d = document.createElement('div'); d.id = 'slowTip'; d.className = 'slowTip'; d.textContent = `Time dilated for ${seconds}s`;
        document.body.appendChild(d);
        if (slowTipTimer) clearTimeout(slowTipTimer);
        slowTipTimer = setTimeout(()=>{ d.remove(); slowTipTimer = null; }, seconds * 1000);
      }
      const bullets = [];
      const enemies = [];
      const player = { x: w / 2, y: h - 60, size: 18, speed: 6 };
      let gameOver = false;
      // HUD canvas
      const hud = document.getElementById('hud');
      const ctxHud = hud.getContext('2d');
      function resizeCanvases(){
        w = canvas.width = innerWidth;
        h = canvas.height = innerHeight;
        hud.width = innerWidth;
        hud.height = innerHeight;
      }
      window.addEventListener('resize', resizeCanvases);
      resizeCanvases();

      function updateScore(){
        const scoreEl = document.getElementById('scoreDisplay');
        const missEl = document.getElementById('missDisplaySmall');
        const playerEl = document.getElementById('playerNameDisplay');
        const uidEl = document.getElementById('uid');
        if (scoreEl) scoreEl.textContent = score;
        if (missEl) missEl.textContent = `${missed}/${missedLimit}`;
        if (playerEl) playerEl.textContent = `Player: ${playerName || '—'}`;
        if (uidEl) uidEl.textContent = window._fbUser ? `uid: ${window._fbUser.uid}` : 'not signed in';
        // keep small status for controls for dev visibility
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function spawnEnemy(){ if (gameOver || paused || !started) return; 
        // red spawn suppressed while redDisabledUntil in future
        const canSpawnRed = Date.now() > redDisabledUntil;
        const isRed = canSpawnRed && (Math.random() < 0.25);
        const size = isRed ? 20 : 18; enemies.push({ x: Math.random() * (w - 40) + 20, y: -20, size: size, speed: 1 + Math.random() * 1.8, type: isRed ? 'red' : 'green' }); }

      // draw player on HUD so it appears above controls
      function drawPlayer(){
        ctxHud.fillStyle = '#0f0';
        ctxHud.beginPath();
        ctxHud.moveTo(player.x, player.y - player.size);
        ctxHud.lineTo(player.x - player.size, player.y + player.size);
        ctxHud.lineTo(player.x + player.size, player.y + player.size);
        ctxHud.closePath();
        ctxHud.fill();
      }
      function drawBullets(){ ctx.fillStyle = '#0ff'; bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10)); }
      function drawEnemies(){
        enemies.forEach(e => {
          if (e.type === 'green') {
            ctx.fillStyle = '#69f0ae'; // green
            ctx.beginPath(); ctx.arc(e.x, e.y, e.size/2, 0, Math.PI*2); ctx.fill();
          } else {
            ctx.fillStyle = '#ff5252'; // red
            ctx.beginPath(); ctx.arc(e.x, e.y, e.size/2, 0, Math.PI*2); ctx.fill();
          }
        });
      }

      function moveBullets(){ for (let i = bullets.length -1; i >=0; i--){ bullets[i].y -= 8; if (bullets[i].y < -10) bullets.splice(i,1); } }
      function moveEnemies(){
        for (let i = enemies.length -1; i>=0; i--){
          const e = enemies[i];
          e.y += e.speed * getEffectiveSpeedFactor();
          // collision with player (collect when touching)
          const dx = e.x - player.x;
          const dy = e.y - player.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < (e.size/2 + player.size/2)) {
            // player collects particle
            if (e.type === 'green') {
              score += 1;
            } else {
              // touching red costs points unless immortal cheat active or ultraMode
              if (ultraMode){ score += 1000; } else if (Date.now() < immortalRedUntil) { /* no effect */ } else { score -= 5; }
            }
            enemies.splice(i,1);
            updateScore();
            continue;
          }
          if (e.y > h - 10) {
            // reached floor
            if (e.type === 'green') {
              // missing green counts toward loss unless ultraMode
              if (!ultraMode) { missed++; updateScore(); if (missed >= missedLimit) { gameOver = true; showGameOver(); return; } }
            } else {
              // red left to fall: reward +10 and brief slow motion
              score += 10; updateScore(); applySlow(5);
            }
            enemies.splice(i,1);
          }
        }
      }
      function handleCollisions(){
        for (let i = enemies.length -1; i>=0; i--){
          for (let j = bullets.length -1; j>=0; j--){
            const dx = enemies[i].x - bullets[j].x;
            const dy = enemies[i].y - bullets[j].y;
            const dist = Math.sqrt(dx*dx+dy*dy);
            if (dist < enemies[i].size/2 + 6){
              // bullet hit particle
              const p = enemies[i];
              // create shatter
              const color = p.type === 'green' ? '#69f0ae' : '#ff5252';
              createShatter(p.x, p.y, color);
              // play appropriate sound
              try{ if (p.type === 'green') coinSound.play().catch(()=>{}); else blastSound.play().catch(()=>{}); }catch(e){}
              // scoring rules: ultraMode or normal
              if (ultraMode){
                // every hit adds 100, red gives 1000
                if (p.type === 'green') score += 100; else score += 1000;
              } else {
                if (p.type === 'green') score += 1; else score -= 5;
              }
              // remove both
              enemies.splice(i,1);
              bullets.splice(j,1);
              updateScore();
              break;
            }
          }
        }
      }

      function shoot(){ bullets.push({ x: player.x, y: player.y - player.size }); }
      let lastShot = 0;

      let _lastFrame = 0;
      function gameLoop(ts){
        if (gameOver) return;
        if (!_lastFrame) _lastFrame = ts;
        const dt = ts - _lastFrame;
        _lastFrame = ts;
        ctx.clearRect(0,0,w,h);
        // clear HUD each frame and redraw player on top
        ctxHud.clearRect(0,0,hud.width,hud.height);
        
        // pause handling
        if (paused) { requestAnimationFrame(gameLoop); return; }

        // controls
        if (controls.left) player.x = Math.max(player.size, player.x - player.speed);
        if (controls.right) player.x = Math.min(w - player.size, player.x + player.speed);
        // faster fire rate: allow shooting every 100ms while action is held or when autoFire is on
        const firing = autoFire ? true : controls.action;
        if (firing && ts - lastShot > 100){ shoot(); lastShot = ts; }

        // keyboard fallback handled via controls state
        if (!paused && Math.random() < getSpawnChance()) spawnEnemy();
        moveBullets(); moveEnemies(); handleCollisions();
        // refresh cheat button and countdowns
        refreshCheatButton(); updateCheatCountdowns();
        // draw enemies and bullets on main canvas
        drawBullets(); drawEnemies();
        // draw shatter effects (from hits)
        updateAndDrawEffects(dt);
        // draw player on HUD so it's above controls
        drawPlayer();
        requestAnimationFrame(gameLoop);
      }

      // populate leaderboard (uses Firebase-loaded data if available). Shows up to 10 entries.
      function populateLeaderboard(){
        const list = document.getElementById('leaderboard');
        if (!list) return;
        const fb = window._fbLeaderboard || [];
        const max = 10;
        list.innerHTML = '';
        for (let i=0;i<max;i++){
          const it = fb[i] || null;
          const li = document.createElement('li'); li.style.display='flex'; li.style.alignItems='center'; li.style.gap='8px'; li.style.padding='6px 4px';
          const rank = document.createElement('span'); rank.className = 'rank'; rank.textContent = (i+1);
          if (i===0) rank.classList.add('r1'); if (i===1) rank.classList.add('r2'); if (i===2) rank.classList.add('r3');
          const txt = document.createElement('div'); txt.style.flex='1';
          if (it) txt.textContent = `${it.name} — ${it.score}`; else txt.textContent = `—`;
          li.appendChild(rank); li.appendChild(txt); list.appendChild(li);
        }
        // also render a compact top-5 into the start panel (if present)
        try{
          const startList = document.getElementById('startLeaderboardList');
          if (startList){ startList.innerHTML = ''; const top = Math.min(5, fb.length); for (let i=0;i<5;i++){ const it = fb[i] || null; const li2 = document.createElement('li'); li2.style.padding='4px 0'; if (it) li2.textContent = `${i+1}. ${it.name} — ${it.score}`; else li2.textContent = `${i+1}. —`; startList.appendChild(li2); } }
        }catch(e){/* ignore */}
      }
      // initial render (will be updated when Firebase data loads)
      populateLeaderboard();
      // listen for fb updates
      window.addEventListener('fbLeaderboardUpdated', ()=>{ populateLeaderboard(); try{ if (window.updateScore) window.updateScore(); }catch(e){} fbDebug('leaderboard UI updated'); });
      updateScore();

      // Background music playlist (start when player clicks Start)
      const bgTracks = [
        'files/audio/Green is good .mp3',
        'files/audio/Green is good techno.mp3'
      ];
      let bgIndex = Math.floor(Math.random() * bgTracks.length);
      const bgAudio = new Audio(); bgAudio.preload = 'auto'; bgAudio.volume = 0.55;
      bgAudio.addEventListener('ended', ()=>{
        bgIndex = (bgIndex + 1) % bgTracks.length; bgAudio.src = bgTracks[bgIndex]; bgAudio.play().catch(()=>{});
      });

      // Start button wiring
      const startBtn = document.getElementById('btnStart');
      const startPanel = document.getElementById('startPanel');
      const nameInput = document.getElementById('playerNameInput');
      startBtn.addEventListener('click', async ()=>{
        const val = nameInput.value.trim();
        if (!val){
          // indicate error
          nameInput.style.border = '1px solid #ff5252';
          setTimeout(()=>{ nameInput.style.border = ''; }, 1200);
          return;
        }
        playerName = val;
        // ensure anonymous auth exists (create new auth UID for this player session)
        try{
          const uidEl = document.getElementById('uid');
          if (uidEl) uidEl.textContent = 'signing in...';
          if (window.refreshAnonUser){ fbDebug('creating anonymous auth...');
            // race the refresh against a client-side timeout so we never hang
            const newUser = await Promise.race([
              window.refreshAnonUser(),
              new Promise(res => setTimeout(() => res(null), 9000))
            ]);
            if (newUser){ fbDebug('signed in as ' + newUser.uid); }
            else { fbDebug('anonymous sign-in failed or timed out','error'); const uidEl2 = document.getElementById('uid'); if (uidEl2) uidEl2.textContent = 'sign-in failed';
              // do not continue starting the game if sign-in failed — user needs to fix Auth/Authorized domains
              alert('Sign-in failed. Check Firebase Authentication (Anonymous) and Authorized domains. See FB debug.');
              return;
            }
          }
        }catch(e){ console.warn('refreshAnonUser failed', e); fbDebug('refreshAnonUser exception: '+(e&&e.message),'warn'); const uidEl2 = document.getElementById('uid'); if (uidEl2) uidEl2.textContent = 'sign-in failed'; alert('Sign-in exception — check console and FB debug'); return; }
        // ensure UI reflects latest auth state
        try{ updateScore(); }catch(e){}
        // create a random id for this play session and immediately write a leaderboard entry (score 0)
        try{
          const genId = 'p_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
          window._currentEntryId = genId;
          try{
            const ref = doc(db, 'leaderboard', genId);
            // write the authenticated user's UID into the document body so Firestore rules
            // that require request.resource.data.uid == request.auth.uid pass even when
            // the document id is a generated session id (p_...)
            const authUidForCreate = (window._fbUser && window._fbUser.uid) ? window._fbUser.uid : genId;
            await setDoc(ref, { uid: authUidForCreate, name: playerName, score: 0, ts: Date.now() });
            fbDebug('created leaderboard entry: ' + genId);
            // refresh local leaderboard view
            if (window.loadTopScores) await window.loadTopScores();
          }catch(e){ console.warn('initial leaderboard write failed', e); fbDebug('initial leaderboard write failed: '+(e && e.message),'warn'); }
        }catch(e){ console.warn('create entry id failed', e); }
        started = true;
        startPanel.style.display = 'none';
        updateScore();
        lastShot = 0;
        // start background audio
        try{ bgAudio.src = bgTracks[bgIndex]; bgAudio.play().catch(()=>{}); }catch(e){}
        // begin loop
        requestAnimationFrame(gameLoop);
      });
      nameInput.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter') startBtn.click(); });

      // Credits dialog
      const creditsDialog = document.createElement('div');
      creditsDialog.id = 'creditsDialog'; creditsDialog.style.position = 'fixed'; creditsDialog.style.left = '50%'; creditsDialog.style.top = '50%'; creditsDialog.style.transform = 'translate(-50%,-50%)'; creditsDialog.style.background = 'rgba(0,0,0,0.9)'; creditsDialog.style.color = '#fff'; creditsDialog.style.padding = '18px 20px'; creditsDialog.style.borderRadius = '12px'; creditsDialog.style.display = 'none'; creditsDialog.style.zIndex = 120;
      creditsDialog.innerHTML = `<div style="font-size:18px;font-weight:700;margin-bottom:8px">Credits</div><div style="font-size:14px;line-height:1.4">Developed by kmrx<br>Music by suno.ai<br>Thanks to GithubCopilot and GitHub</div><div style="margin-top:14px;text-align:right"><button id='creditsClose' style='padding:6px 10px;border-radius:8px;background:#222;color:#ffd600;border:none'>Close</button></div>`;
      document.body.appendChild(creditsDialog);
      document.getElementById('creditsLink').addEventListener('click', (ev)=>{ ev.preventDefault(); creditsDialog.style.display = 'block'; });
      document.body.addEventListener('click', (ev)=>{ if (ev.target && ev.target.id === 'creditsClose'){ creditsDialog.style.display = 'none'; } });

      // Cheat modal (created hidden)
      const cheatDialog = document.createElement('div'); cheatDialog.id = 'cheatDialog'; cheatDialog.style.position = 'fixed'; cheatDialog.style.left = '50%'; cheatDialog.style.top = '50%'; cheatDialog.style.transform = 'translate(-50%,-50%)'; cheatDialog.style.background = 'rgba(0,0,0,0.95)'; cheatDialog.style.color = '#fff'; cheatDialog.style.padding = '18px 20px'; cheatDialog.style.borderRadius = '12px'; cheatDialog.style.display = 'none'; cheatDialog.style.zIndex = 200;
      cheatDialog.innerHTML = `<div style="font-size:16px;font-weight:700;margin-bottom:8px">Cheat Codes</div>
        <input id='cheatInput' placeholder='Enter cheats (e.g. AD100)' style='width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;margin-bottom:10px' />
        <div style='display:flex;gap:8px;justify-content:flex-end'>
          <button id='cheatApply' style='padding:6px 10px;border-radius:8px;background:var(--accent);color:#022;border:none'>Apply</button>
          <button id='cheatClose' style='padding:6px 10px;border-radius:8px;background:#222;color:#ffd600;border:none'>Close</button>
        </div>`;
      document.body.appendChild(cheatDialog);

      // we'll create a Tools dialog (contains Pause, Auto, Cheats) instead of a standalone cheat button
      let prevPaused = false;

      // cheat state and usage tracking
      const usedCheats = { AD100:0, MISSEDME:0, DAMN1000:0, IMTHEHACKERMF:0, IMIMMORTALMF:0, SLOWGAME60:0, IMULTRALEGENDARYHACKERMF:0 };
      let redDisabledUntil = 0;
      let immortalRedUntil = 0;
      let ultraMode = false; // special ultimate cheat
      let ultraQuitBtn = null;

      // show/close cheat dialog: preserve previous paused state
      function showCheatDialog(){ prevPaused = paused; paused = true; cheatDialog.style.display='block';
        const tcb = document.getElementById('toolsCheatBtn'); if (tcb) tcb.disabled = true; if (window.toolsDialog) window.toolsDialog.style.display='none'; }
      function closeCheatDialog(){ cheatDialog.style.display='none'; const tcb = document.getElementById('toolsCheatBtn'); if (tcb) tcb.disabled = false; paused = (typeof prevPaused !== 'undefined') ? prevPaused : false; }
      document.getElementById('cheatClose').addEventListener('click', ()=>{ closeCheatDialog(); });
      document.getElementById('cheatApply').addEventListener('click', ()=>{ const code = document.getElementById('cheatInput').value.trim().toUpperCase(); applyCheat(code); document.getElementById('cheatInput').value=''; });

      // Tools dialog (contains Pause, Auto and Cheats). Created hidden; opened by #btnTools
      const toolsDialog = document.createElement('div');
      toolsDialog.id = 'toolsDialog';
      toolsDialog.style.position = 'fixed';
      toolsDialog.style.right = '16px';
      toolsDialog.style.top = '48px';
      toolsDialog.style.background = 'rgba(6,8,18,0.95)';
      toolsDialog.style.color = '#fff';
      toolsDialog.style.padding = '12px';
      toolsDialog.style.borderRadius = '10px';
      toolsDialog.style.display = 'none';
      toolsDialog.style.zIndex = 220;
      toolsDialog.style.boxShadow = '0 8px 30px rgba(0,0,0,0.6)';
      toolsDialog.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div style="font-weight:700">Tools</div>
          <button id="toolsClose" style="background:transparent;border:none;color:#9fbefc;font-size:16px;">✕</button>
        </div>
        <div style="display:flex;flex-direction:column;gap:8px;min-width:150px">
          <button id="btnPausePlay" style="padding:8px;border-radius:8px;border:none;background:#222;color:#ffd600">Pause</button>
          <button id="btnAutoFire" style="padding:8px;border-radius:8px;border:none;background:#222;color:#40c4ff">Auto: Off</button>
          <button id="toolsCheatBtn" style="padding:8px;border-radius:8px;border:none;background:var(--panel);color:var(--accent)">Cheats</button>
        </div>
      `;
      document.body.appendChild(toolsDialog);
      window.toolsDialog = toolsDialog;

      // wire tools toggle button
      const toolsBtnEl = document.getElementById('btnTools');
      function openToolsDialog(){ prevPaused = paused; paused = true; toolsDialog.style.display = 'block'; toolsBtnEl.classList.add('pressed');
        try{ const pb = document.getElementById('btnPausePlay'); if (pb) pb.textContent = paused ? 'Play' : 'Pause'; }catch(e){}
      }
      function closeToolsDialog(){
        toolsDialog.style.display = 'none';
        toolsBtnEl.classList.remove('pressed');
        // if user left the dialog without toggling pause (paused still true), restore previous paused state
        if (typeof prevPaused !== 'undefined' && paused === true){ paused = prevPaused; }
        try{ const pb = document.getElementById('btnPausePlay'); if (pb) pb.textContent = paused ? 'Play' : 'Pause'; }catch(e){}
      }
      if (toolsBtnEl){ toolsBtnEl.addEventListener('click', ()=>{ if (toolsDialog.style.display === 'block') closeToolsDialog(); else openToolsDialog(); }); }
      // keyboard shortcut: 'T' or 't' toggles Tools dialog (ignore when typing in inputs)
      window.addEventListener('keydown', function(e){
        if (!e || !e.key) return;
        const active = document.activeElement;
        const inInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable);
        if (inInput) return; // don't interfere with typing
        if (e.key === 't' || e.key === 'T'){
          if (toolsDialog.style.display === 'block') closeToolsDialog(); else openToolsDialog();
        }
      });
      // close button inside dialog
      toolsDialog.addEventListener('click', (ev)=>{ if (ev.target && ev.target.id === 'toolsClose'){ closeToolsDialog(); } });
      // wire the inner cheat button to open the cheat dialog (and close tools dialog)
      toolsDialog.addEventListener('click', (ev)=>{ if (ev.target && ev.target.id === 'toolsCheatBtn'){ closeToolsDialog(); showCheatDialog(); } });

      const overlay = document.createElement('div');
      overlay.id = 'gameOverPanel';
      overlay.style.position = 'fixed';
      overlay.style.left = '50%';
      overlay.style.top = '50%';
      overlay.style.transform = 'translate(-50%,-50%)';
      overlay.style.background = 'rgba(0,0,0,0.85)';
      overlay.style.color = '#fff';
      overlay.style.padding = '20px 28px';
      overlay.style.borderRadius = '12px';
      overlay.style.display = 'none';
      overlay.style.zIndex = 60;
      overlay.innerHTML = `<div style="font-size:20px;margin-bottom:8px;">Game Over</div><div style="margin-bottom:12px;">Missed: <span id='missCount'>0</span>/10</div><button id='btnRestart' style='padding:8px 12px;border-radius:8px;background:#222;color:#ffd600;border:none'>Restart</button>`;
      document.body.appendChild(overlay);
      async function showGameOver(){
        // save score to Firestore (if available) and refresh leaderboard
        try{
          if (window.saveScoreToFirestore) await window.saveScoreToFirestore(playerName || 'Player', score);
          if (window.loadTopScores) await window.loadTopScores();
        }catch(e){ console.warn('Error saving/loading leaderboard', e); }

        const fb = window._fbLeaderboard || [];
        const max = 10;
        let lb = '<div style="text-align:left;margin-top:8px"><ol style="list-style:none;padding:0;margin:0">';
        for (let i=0;i<max;i++){
          const it = fb[i] || null;
          const rankClass = i===0? 'r1' : (i===1? 'r2' : (i===2? 'r3':''));
          const nameText = it ? it.name : '—';
          const scoreText = it ? it.score : '—';
          lb += `<li style="display:flex;align-items:center;gap:8px;padding:6px 0"><span class="rank ${rankClass}" style="width:28px;height:28px;border-radius:6px;display:inline-flex;align-items:center;justify-content:center;font-weight:800">${i+1}</span><div style="flex:1">${nameText} — ${scoreText}</div></li>`;
        }
        lb += '</ol></div>';

        overlay.innerHTML = `
          <div style="font-size:20px;margin-bottom:8px;">Game Over</div>
          <div style="margin-bottom:6px;">Player: ${playerName || '—'}</div>
          <div style="margin-bottom:6px;">Score: ${score}</div>
          <div style="margin-bottom:12px;">Missed: <span id='missCount'>${missed}</span>/${missedLimit}</div>
          <div style="text-align:left;margin-bottom:12px"><strong>Leaderboard</strong>${lb}</div>
          <div style="display:flex;gap:8px;justify-content:center">
            <button id='btnRestart' style='padding:8px 12px;border-radius:8px;background:#222;color:#ffd600;border:none'>Restart</button>
            <button id='btnHome' style='padding:8px 12px;border-radius:8px;background:#222;color:#40c4ff;border:none'>Home</button>
          </div>`;
        overlay.style.display = 'block';
      }
      
      // Cheat application logic
      function applyCheat(code){
        if (!code) return;
        if (code === 'AD100'){
          if (usedCheats.AD100) return alert('AD100 already used this game');
          score += 100; usedCheats.AD100 = 1; updateScore();
          if (window.saveUserState) window.saveUserState({ usedCheats, name: playerName });
          alert('Added 100 points'); return;
        }
        if (code === 'MISSEDME'){
          if (usedCheats.MISSEDME >= 3) return alert('MISSEDME used max times');
          missed = 0; usedCheats.MISSEDME += 1; updateScore();
          if (window.saveUserState) window.saveUserState({ usedCheats, name: playerName });
          alert('Missed reset'); return;
        }
        if (code === 'DAMN1000'){
          if (usedCheats.DAMN1000) return alert('DAMN1000 already used');
          score += 1000; usedCheats.DAMN1000 = 1; updateScore();
          if (window.saveUserState) window.saveUserState({ usedCheats, name: playerName });
          alert('Added 1000 points'); return;
        }
        if (code === 'IMTHEHACKERMF'){
          if (usedCheats.IMTHEHACKERMF) return alert('Cheat already used');
          usedCheats.IMTHEHACKERMF = 1; redDisabledUntil = Date.now() + 60000; // remove red spawn
          // remove existing red particles
          for (let i = enemies.length -1; i>=0; i--){ if (enemies[i].type === 'red') enemies.splice(i,1); }
          if (window.saveUserState) window.saveUserState({ usedCheats, name: playerName });
          alert('Red particles removed for 60s'); return;
        }
        if (code === 'IMIMMORTALMF'){
          if (usedCheats.IMIMMORTALMF) return alert('Cheat already used');
          usedCheats.IMIMMORTALMF = 1; immortalRedUntil = Date.now() + 60000; if (window.saveUserState) window.saveUserState({ usedCheats, name: playerName }); alert('Immortal red active for 60s'); return;
        }
        if (code === 'SLOWGAME60'){
          if (usedCheats.SLOWGAME60) return alert('Cheat already used');
          usedCheats.SLOWGAME60 = 1; applySlow(60); if (window.saveUserState) window.saveUserState({ usedCheats, name: playerName }); alert('Game slowed for 60s'); return;
        }
        if (code === 'DEF'){
          // reset settings back to default but preserve score and used cheats
          speedFactor = 1; slowUntil = 0; redDisabledUntil = 0; immortalRedUntil = 0; effects.length = 0; updateScore(); if (window.saveUserState) window.saveUserState({ usedCheats, name: playerName }); alert('Settings reset (score preserved)'); return;
        }
        if (code === 'IMULTRALEGENDARYHACKERMF'){
          if (usedCheats.IMULTRALEGENDARYHACKERMF) return alert('Cheat already used');
          usedCheats.IMULTRALEGENDARYHACKERMF = 1; ultraMode = true;
          // show quit button in top controls
          if (!ultraQuitBtn){ ultraQuitBtn = document.createElement('button'); ultraQuitBtn.id='btnQuit'; ultraQuitBtn.textContent='Quit'; ultraQuitBtn.style.marginLeft='6px'; ultraQuitBtn.style.padding='6px 8px'; ultraQuitBtn.style.borderRadius='8px'; ultraQuitBtn.style.background='#600'; ultraQuitBtn.style.color='#fff'; document.getElementById('topControls').appendChild(ultraQuitBtn); ultraQuitBtn.addEventListener('click', ()=>{ gameOver = true; showGameOver(); }); }
          if (window.saveUserState) window.saveUserState({ usedCheats, name: playerName });
          alert('Ultra mode enabled'); return;
        }
        alert('Unknown cheat code');
      }
      // show cheat countdowns below missed count
      const cheatCountdownEl = document.createElement('div'); cheatCountdownEl.id='cheatCountdown'; cheatCountdownEl.style.fontSize='12px'; cheatCountdownEl.style.color='var(--muted)'; cheatCountdownEl.style.marginTop='6px'; document.getElementById('leftPanel').appendChild(cheatCountdownEl);

      // update UI when firebase auth / user state changes
      window.addEventListener('fbAuthChanged', ()=>{ updateScore(); });
      window.addEventListener('fbUserStateUpdated', ()=>{
        // merge saved usedCheats into runtime
        try{
          if (window._fbUserState && window._fbUserState.usedCheats){
            Object.keys(window._fbUserState.usedCheats).forEach(k => { if (usedCheats.hasOwnProperty(k)) usedCheats[k] = window._fbUserState.usedCheats[k]; });
            updateScore();
          }
        }catch(e){/* ignore */}
      });

      // wire pause/auto buttons and restart behavior
      const btnPause = document.getElementById('btnPausePlay');
      const btnAuto = document.getElementById('btnAutoFire');
      btnPause.addEventListener('click', ()=>{
        paused = !paused;
        btnPause.textContent = paused ? 'Play' : 'Pause';
      });
      btnAuto.addEventListener('click', ()=>{
        autoFire = !autoFire;
        btnAuto.textContent = autoFire ? 'Auto fire: On' : 'Auto fire: Off';
      });

      // Hook cheat button visibility while playing (controls visibility of the cheat button inside Tools dialog)
      function refreshCheatButton(){ const tcb = document.getElementById('toolsCheatBtn'); if (tcb) tcb.style.display = (started && !gameOver) ? 'block' : 'none'; }
      // update cheat countdowns
      function updateCheatCountdowns(){
        const now = Date.now();
        const parts = [];
        if (redDisabledUntil > now) parts.push(`No-Red: ${Math.ceil((redDisabledUntil-now)/1000)}s`);
        if (immortalRedUntil > now) parts.push(`ImmortalRed: ${Math.ceil((immortalRedUntil-now)/1000)}s`);
        if (slowUntil > now) parts.push(`Slow: ${Math.ceil((slowUntil-now)/1000)}s`);
        cheatCountdownEl.textContent = parts.join('  •  ');
      }

      document.body.addEventListener('click', (e)=>{
        if (!e.target) return;
        if (e.target.id === 'btnRestart'){
          // reset and start immediately (keep player name)
          missed = 0; score = 0; enemies.length = 0; bullets.length = 0; gameOver = false; paused = false; autoFire = false; started = true;
          overlay.style.display = 'none';
          startPanel.style.display = 'none';
          btnPause.textContent = 'Pause';
          btnAuto.textContent = 'Auto: Off';
          updateScore();
          // reset cheat timers except usedCheats remain
          redDisabledUntil = 0; immortalRedUntil = 0; slowUntil = 0; ultraMode = false;
          if (ultraQuitBtn){ ultraQuitBtn.remove(); ultraQuitBtn = null; }
          requestAnimationFrame(gameLoop);
        }
        if (e.target.id === 'btnHome'){
          // go back to start panel (do not start)
          missed = 0; score = 0; enemies.length = 0; bullets.length = 0; gameOver = false; paused = false; autoFire = false; started = false;
          overlay.style.display = 'none';
          startPanel.style.display = 'block';
          nameInput.focus();
          btnPause.textContent = 'Pause';
          btnAuto.textContent = 'Auto: Off';
          updateScore();
        }
        // credits close handled earlier
      });
    </script>
  </body>
</html>