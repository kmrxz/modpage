<!doctype html>
<html lang="en"> 
 <head> 
  <meta charset="UTF-8"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <title>3D Animation with Particles</title> 
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style> 
 </head> 
 <body> 
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

    // Scene, Camera, and Renderer Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffffff, 1, 50);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    // Particle System
    const particleCount = 50000;
    const particlesGeometry = new THREE.BufferGeometry();
    const particlesMaterial = new THREE.PointsMaterial({ color: 0xA259FF, size: 0.02 }); // Purple
    particlesMaterial.sizeAttenuation = true;
    particlesMaterial.shape = 'circle'; // Ensures circle shape

    const particlePositions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount * 3; i++) {
      particlePositions[i] = (Math.random() - 0.5) * 10;
    }
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

    const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particleSystem);

    // Linking logic
    function drawLinks() {
      const positions = particlesGeometry.getAttribute('position');
      for (let i = 0; i < particleCount; i++) {
        const xi = positions.getX(i), yi = positions.getY(i), zi = positions.getZ(i);
        for (let j = i + 1; j < particleCount; j++) {
          const xj = positions.getX(j), yj = positions.getY(j), zj = positions.getZ(j);
          const dx = xi - xj, dy = yi - yj, dz = zi - zj;
          const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
          if (dist < 0.18) { // threshold for linking
            // Project 3D to 2D
            const v1 = new THREE.Vector3(xi, yi, zi).project(camera);
            const v2 = new THREE.Vector3(xj, yj, zj).project(camera);
            const x1 = (v1.x * 0.5 + 0.5) * renderer.domElement.width;
            const y1 = (-v1.y * 0.5 + 0.5) * renderer.domElement.height;
            const x2 = (v2.x * 0.5 + 0.5) * renderer.domElement.width;
            const y2 = (-v2.y * 0.5 + 0.5) * renderer.domElement.height;
            const ctx2d = renderer.getContext();
            ctx2d.save();
            ctx2d.strokeStyle = 'rgba(100,180,255,0.35)'; // Light blue
            ctx2d.lineWidth = 1.2;
            ctx2d.beginPath();
            ctx2d.moveTo(x1, y1);
            ctx2d.lineTo(x2, y2);
            ctx2d.stroke();
            ctx2d.restore();
          }
        }
      }
    }

    // User Interaction - Rotate Camera with Mouse
    let mouseX = 0, mouseY = 0;

    document.addEventListener('mousemove', (event) => {
      mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    // Animation Loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);

      // Animate Particle System
      particleSystem.rotation.y += 0.002;

      // Move Camera Slightly Based on Mouse
      camera.position.x += (mouseX * 5 - camera.position.x) * 0.05;
      camera.position.y += (mouseY * 5 - camera.position.y) * 0.05;
      camera.lookAt(scene.position);

      // Render Scene
      renderer.render(scene, camera);
      drawLinks();
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script> 
 </body>
</html>