<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
<!-- Backup of corrupted blaster.html created Dec 5, 2025 -->
<!-- If you need to restore the corrupted version, copy this file back to blaster.html -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blaster</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top: 10px; left: 10px; z-index: 2; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Blaster — Demo</title>
    <style>
      body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;min-height:100vh}
      main{flex:1;display:flex;align-items:center;justify-content:center}
      h1{font-size:2rem;margin:0}
      /* Mobile control bar */
      .controls{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;background:linear-gradient(180deg,rgba(0,0,0,0.0),rgba(0,0,0,0.6));display:flex;gap:12px;justify-content:center;align-items:flex-end}
      .btn{width:84px;height:84px;border-radius:18px;background:#222;border:2px solid #444;color:#fff;font-size:16px;display:flex;align-items:center;justify-content:center;touch-action:none;-webkit-tap-highlight-color:transparent}
      .btn:active,.btn.pressed{background:#ffd600;color:#000}
      .btn.wide{width:140px}
      .status{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    </style>
  </head>
    let score = 0;

    const player = { x: w / 2, y: h - 60, size: 20, speed: 6 };
    <div class="status" id="ctrlStatus">Left: up • Action: up • Right: up</div>
    <main>
      <h1>Demo</h1>
    </main>

    <div class="controls" aria-hidden="false">
      <button id="btnLeft" class="btn" aria-label="Left">◀</button>
      <button id="btnAction" class="btn wide" aria-label="Action">Fire</button>
      <button id="btnRight" class="btn" aria-label="Right">▶</button>
    </div>

    <script>
      // Simple mobile control bindings — these functions are placeholders
      const statusEl = document.getElementById('ctrlStatus');
      const leftBtn = document.getElementById('btnLeft');
      const rightBtn = document.getElementById('btnRight');
      const actionBtn = document.getElementById('btnAction');

      const controls = { left:false, right:false, action:false };

      function updateStatus(){
        statusEl.textContent = `Left: ${controls.left? 'down':'up'} • Action: ${controls.action? 'down':'up'} • Right: ${controls.right? 'down':'up'}`;
      }

      function bindButton(el, key) {
        // start
        const start = (ev)=>{ ev.preventDefault(); controls[key]=true; el.classList.add('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlstart',{detail:{key}})); };
        // end
        const end = (ev)=>{ ev.preventDefault(); controls[key]=false; el.classList.remove('pressed'); updateStatus(); window.dispatchEvent(new CustomEvent('controlend',{detail:{key}})); };
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start);
        el.addEventListener('mouseup', end);
        el.addEventListener('mouseleave', end);
      }

      bindButton(leftBtn,'left');
      bindButton(rightBtn,'right');
      bindButton(actionBtn,'action');

      // Keyboard fallback for desktop testing
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = true; leftBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = true; rightBtn.classList.add('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = true; actionBtn.classList.add('pressed'); updateStatus(); }
      });
      window.addEventListener('keyup', (e)=>{
        if (e.key === 'ArrowLeft') { controls.left = false; leftBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === 'ArrowRight') { controls.right = false; rightBtn.classList.remove('pressed'); updateStatus(); }
        if (e.key === ' ' || e.key === 'Spacebar') { controls.action = false; actionBtn.classList.remove('pressed'); updateStatus(); }
      });

      // Expose a simple API for integration with game code
      window.gameControls = {
        isDown: (k) => !!controls[k],
        onStart: (fn) => window.addEventListener('controlstart', (e)=>fn(e.detail.key)),
        onEnd: (fn) => window.addEventListener('controlend', (e)=>fn(e.detail.key))
      };

      // initial status
      updateStatus();
    </script>
  </body>
    const bullets = [];
    const enemies = [];

    const updateScore = () => document.getElementById('score').textContent = `Score: ${score}`;

    function spawnEnemy() {
      enemies.push({
        x: Math.random() * (w - 40) + 20,
        y: -20,
        size: 20,
        speed: 2 + Math.random() * 2
      });
    }

    function drawPlayer() {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.size);
      ctx.lineTo(player.x - player.size, player.y + player.size);
      ctx.lineTo(player.x + player.size, player.y + player.size);
      ctx.closePath();
      ctx.fill();
    }

    function drawBullets() {
      ctx.fillStyle = '#0ff';
      bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 10, 4, 10));
    }

    function drawEnemies() {
      ctx.fillStyle = '#f00';
      enemies.forEach(e => ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size));
    }

    function moveBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 8;
        if (bullets[i].y < -10) bullets.splice(i, 1);
      }
    }

    function moveEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > h + enemies[i].size) enemies.splice(i, 1);
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          const dx = enemies[i].x - bullets[j].x;
          const dy = enemies[i].y - bullets[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < enemies[i].size / 2 + 6) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 10;
            updateScore();
            break;
          }
        }
      }
    }

    const keys = {};
    addEventListener('keydown', e => keys[e.key] = true);
    addEventListener('keyup', e => keys[e.key] = false);
    addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function shoot() {
      bullets.push({ x: player.x, y: player.y - player.size });
    }

    let lastShot = 0;
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, w, h);
      if (keys['ArrowLeft']) player.x = Math.max(player.size, player.x - player.speed);
      if (keys['ArrowRight']) player.x = Math.min(w - player.size, player.x + player.speed);
      if (keys[' '] && timestamp - lastShot > 250) {
        shoot();
        lastShot = timestamp;
      }

      if (Math.random() < 0.02) spawnEnemy();

      moveBullets();
      moveEnemies();
      handleCollisions();

      drawPlayer();
      drawBullets();
      drawEnemies();

      requestAnimationFrame(gameLoop);
    }

    updateScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
