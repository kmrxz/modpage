<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Valentine Card</title>

<style>
:root{
  --bg:#ffeef3;
  --card:#fff5f8;
  --accent:#ff6b91;
  --accent2:#ff9bb3;
  --text:#3a2b2b;
}

*{box-sizing:border-box}
body{
  margin:0;
  height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  background:linear-gradient(180deg,var(--bg),#fff);
  font-family:system-ui,Segoe UI,Roboto;
  color:var(--text);
}

.card{
  width:min(680px,94vw);
  padding:36px;
  background:linear-gradient(180deg,var(--card),#fff);
  border-radius:20px;
  box-shadow:0 10px 30px rgba(0,0,0,.12);
  text-align:center;
}

.heart{
  width:120px;
  height:100px;
  margin:0 auto 16px;
  position:relative;
  animation:beat 1.5s infinite;
}
.heart::before,.heart::after{
  content:"";
  position:absolute;
  width:60px;
  height:95px;
  background:linear-gradient(180deg,var(--accent),var(--accent2));
  border-radius:60px 60px 0 0;
  top:0;
}
.heart::before{left:60px;transform:rotate(-45deg);transform-origin:0 100%}
.heart::after{left:0;transform:rotate(45deg);transform-origin:100% 100%}

@keyframes beat{
  0%,100%{transform:scale(1)}
  50%{transform:scale(1.06)}
}

.actions{
  position:relative;
  height:90px;
  display:flex;
  justify-content:center;
  align-items:center;
  gap:20px;
}

button{
  border:none;
  padding:12px 22px;
  border-radius:999px;
  font-weight:600;
  cursor:pointer;
  color:#fff;
  background:linear-gradient(90deg,var(--accent),var(--accent2));
  box-shadow:0 8px 18px rgba(0,0,0,.15);
}

.yes, .no{
  transition:transform .15s linear;
}

.actions.fixed-grid{
  position:fixed;
  display:grid;
  grid-template-columns: auto auto;
  gap:120px;
  align-items:center;
  justify-items:center;
  z-index:60;
  padding:28px 36px; /* larger internal padding to keep buttons away from edges */
  border-radius:20px;
  background:transparent;
}
.actions.fixed-grid .yes,
.actions.fixed-grid .no{
  position:relative;
}

.overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.3);
  opacity:0;
  pointer-events:none;
  transition:.25s;
}
.overlay.show{
  opacity:1;
  pointer-events:auto;
}
.float-heart{
  position:fixed;
  bottom:-40px;
  pointer-events:none;
  width:28px;
  height:28px;
  transform:translateY(0) rotate(0deg);
  background:linear-gradient(180deg,#ff6b91,#ff9bb3);
  border-radius:50% 50% 50% 50% / 60% 60% 40% 40%;
  filter:drop-shadow(0 6px 12px rgba(0,0,0,.08));
  animation-name:floatUp;
  animation-timing-function:linear;
  animation-iteration-count:1;
  z-index:1;
}
@keyframes floatUp{
  0%{transform:translateY(0) rotate(0deg);opacity:1}
  20%{transform:translateY(-8vh) rotate(10deg);opacity:1}
  100%{transform:translateY(-120vh) rotate(60deg);opacity:0}
}
.dialog{
  background:#fff;
  padding:24px;
  border-radius:14px;
  max-width:420px;
  text-align:center;
}
.close{
  margin-top:12px;
  background:none;
  border:2px solid var(--accent);
  color:var(--accent);
}
</style>
</head>

<body>
<div class="card">
  <div class="heart"></div>
  <h2>Will you be my valentine?</h2>
  <p>I picked a heart just for you üíñ</p>

  <div class="actions" id="actions">
    <button class="yes" id="yes">Yes</button>
    <button class="no" id="no">No</button>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="dialog">
    <h3>You made my day ‚ù§Ô∏è</h3>
    <p>Two hearts, one beat.</p>
    <button class="close" id="close">Close</button>
  </div>
</div>

<script>
const actions = document.getElementById("actions");
const no = document.getElementById("no");
const yes = document.getElementById("yes");
const overlay = document.getElementById("overlay");
const close = document.getElementById("close");

let bounds;
const THRESHOLD = 100; // keep cursor at least this far from button center
const GAP = 140; // legacy gap used for larger random moves
const EDGE_GAP = 28; // distance from container wall to button center
let isBouncing = false;

function updateBounds(){
  const r = actions.getBoundingClientRect();
  const noRect = no.getBoundingClientRect();
  const halfW = r.width/2 - EDGE_GAP - (noRect.width/2);
  const halfH = r.height/2 - EDGE_GAP - (noRect.height/2);
  bounds = {
    minX: -Math.max(20, halfW),
    maxX:  Math.max(20, halfW),
    minY: -Math.max(10, halfH),
    maxY:  Math.max(10, halfH)
  };
}
updateBounds();
window.addEventListener("resize", ()=>{
  updateBounds();
  fixAndSwapButtons();
});

// Fix the actions container as a centered, screen-relative grid and swap button order
function fixAndSwapButtons(){
  const rect = actions.getBoundingClientRect();
  actions.classList.add('fixed-grid');

  // center horizontally on screen, keep vertical position relative to original
  actions.style.left = '50%';
  actions.style.transform = 'translateX(-50%)';
  actions.style.top = rect.top + 'px';

  // make width screen-relative but not too wide
  const w = Math.min(window.innerWidth * 0.6, 560);
  actions.style.width = w + 'px';
  actions.style.height = Math.max(120, rect.height) + 'px';

  // ensure buttons are grid items
  yes.style.position = 'relative';
  no.style.position = 'relative';

  // swap visual order so `No` appears left of `Yes` (or vice versa)
  yes.style.order = '2';
  no.style.order = '1';

  // store original center coordinates for both buttons (used for repulsion math)
  const rYes = yes.getBoundingClientRect();
  const rNo = no.getBoundingClientRect();
  yes._origX = rYes.left + rYes.width/2;
  yes._origY = rYes.top + rYes.height/2;
  no._origX = rNo.left + rNo.width/2;
  no._origY = rNo.top + rNo.height/2;
}

fixAndSwapButtons();

function triggerBounce(){
  if(isBouncing) return;
  isBouncing = true;
  const randX = Math.floor(Math.random()*(bounds.maxX - bounds.minX)) + bounds.minX;
  const randY = Math.floor(Math.random()*(bounds.maxY - bounds.minY)) + bounds.minY;

  no.style.transition = 'transform .28s cubic-bezier(.2,.9,.2,1)';
  no.style.transform = `translate(${randX}px,${randY}px)`;

  // after a short pause, return to origin smoothly
  setTimeout(()=>{
    no.style.transition = 'transform .8s ease';
    no.style.transform = 'translate(0,0)';
    setTimeout(()=>{
      no.style.transition = 'transform .15s linear';
      isBouncing = false;
    }, 850);
  }, 900);
}

// Touch-specific tap animation for devices without cursor
function touchTapAnimate(){
  if(isBouncing) return;
  isBouncing = true;
  // small random hop then return
  const hopX = Math.floor((Math.random() - 0.5) * (bounds.maxX - bounds.minX) * 0.6);
  const hopY = Math.floor((Math.random() - 0.5) * (bounds.maxY - bounds.minY) * 0.6);
  no.style.transition = 'transform .22s ease-out';
  no.style.transform = `translate(${hopX}px,${hopY}px)`;
  setTimeout(()=>{
    no.style.transition = 'transform .6s ease';
    no.style.transform = 'translate(0,0)';
    setTimeout(()=>{
      no.style.transition = 'transform .15s linear';
      isBouncing = false;
    }, 620);
  }, 260);
}

// Move any button outward randomly by at least `minDist` px and return after `returnMs`.
function randomMoveOut(button, minDist = 100, extra = 180, moveMs = 350, returnMs = 900){
  if(button._moving) return;
  button._moving = true;
  const angle = Math.random() * Math.PI * 2;
  const dist = minDist + Math.random() * extra;
  const dx = Math.round(Math.cos(angle) * dist);
  const dy = Math.round(Math.sin(angle) * dist);
  button.style.transition = `transform ${moveMs}ms cubic-bezier(.2,.8,.2,1)`;
  button.style.transform = `translate(${dx}px,${dy}px)`;
  setTimeout(()=>{
    button.style.transition = `transform ${returnMs}ms ease`;
    button.style.transform = 'translate(0,0)';
    setTimeout(()=>{
      button.style.transition = 'transform .15s linear';
      button._moving = false;
    }, returnMs + 20);
  }, moveMs + 20);
}

// When cursor approaches either button, move that button away (all directions).

function repelButton(btn, pointer){
  // If a button is currently doing a click-move or bounce, don't interrupt
  if(btn._moving || isBouncing) return;
  const px = pointer.clientX;
  const py = pointer.clientY;
  const origX = btn._origX;
  const origY = btn._origY;
  if(!origX || !origY) return;

  const dx = origX - px;
  const dy = origY - py;
  const dist = Math.hypot(dx, dy) || 1;

  if(dist < THRESHOLD){
    // place target center at pointer + unit*(THRESHOLD)
    const ux = dx / dist;
    const uy = dy / dist;
    const targetX = px + ux * THRESHOLD;
    const targetY = py + uy * THRESHOLD;

    // compute translate relative to the original center
    const transX = Math.round(targetX - origX);
    const transY = Math.round(targetY - origY);

    // clamp to allowed bounds (relative to actions center)
    const aRect = actions.getBoundingClientRect();
    const aCenterX = aRect.left + aRect.width/2;
    const aCenterY = aRect.top + aRect.height/2;
    const relX = transX; // transform is in px directly
    const relY = transY;
    const clampedX = Math.max(bounds.minX, Math.min(bounds.maxX, relX));
    const clampedY = Math.max(bounds.minY, Math.min(bounds.maxY, relY));

    if(clampedX !== relX || clampedY !== relY){
      // if clamped against a wall, trigger bounce behavior
      triggerBounce();
      return;
    }

    // apply a quick transform to repel the pointer; using a short transition for smoothness
    btn.style.transition = 'transform 140ms cubic-bezier(.2,.9,.2,1)';
    btn.style.transform = `translate(${clampedX}px,${clampedY}px)`;
  } else {
    // return to original when pointer is far enough
    btn.style.transition = 'transform .35s ease';
    btn.style.transform = 'translate(0,0)';
  }
}

function handleProximity(e){
  const pointer = e.type.startsWith('touch') ? e.touches[0] : e;
  repelButton(yes, pointer);
  repelButton(no, pointer);
}

// mouse and touch proximity
actions.addEventListener('mousemove', handleProximity);
actions.addEventListener('touchmove', handleProximity, {passive:true});

// clicks/taps on any button should make it jump outward further
yes.addEventListener('click', ()=> randomMoveOut(yes, 140, 260, 280, 900));
no.addEventListener('click', ()=> randomMoveOut(no, 140, 260, 280, 900));

// Floating hearts: spawn simple hearts periodically
function spawnHeart(){
  const h = document.createElement('div');
  h.className = 'float-heart';
  const size = 12 + Math.floor(Math.random()*28);
  h.style.width = size + 'px';
  h.style.height = size + 'px';
  const left = Math.random() * 100;
  h.style.left = left + 'vw';
  const dur = 6000 + Math.floor(Math.random()*7000);
  h.style.animationDuration = dur + 'ms';
  h.style.opacity = 0.9;
  // subtle scale and border-radius change to look heart-like
  h.style.borderRadius = '50% 50% 50% 50% / 60% 60% 40% 40%';
  document.body.appendChild(h);
  h.addEventListener('animationend', ()=> h.remove());
}
// create a steady stream of hearts
setInterval(spawnHeart, 700);
// spawn a few immediately
for(let i=0;i<6;i++) setTimeout(spawnHeart, i*250);

function moveNo(x,y, pointer){
  if(isBouncing) return;

  const dx = Math.max(bounds.minX, Math.min(bounds.maxX, x));
  const dy = Math.max(bounds.minY, Math.min(bounds.maxY, y));

  // compute a push-away vector if the cursor is too close to the No button
  let pushX = 0, pushY = 0;
  if(pointer){
    const noRect = no.getBoundingClientRect();
    const noCenterX = noRect.left + noRect.width/2;
    const noCenterY = noRect.top + noRect.height/2;
    const mx = pointer.clientX;
    const my = pointer.clientY;
    const dist = Math.hypot(noCenterX - mx, noCenterY - my) || 1;
    if(dist < GAP){
      const pushDist = GAP - dist;
      const ux = (noCenterX - mx) / dist;
      const uy = (noCenterY - my) / dist;
      pushX = ux * pushDist;
      pushY = uy * pushDist;
    }
  }

  const totalX = dx + pushX;
  const totalY = dy + pushY;

  // detect container wall hit ‚Äî if clamping changed the value, treat as a hit
  const clampedX = Math.max(bounds.minX, Math.min(bounds.maxX, totalX));
  const clampedY = Math.max(bounds.minY, Math.min(bounds.maxY, totalY));
  if(clampedX === bounds.minX || clampedX === bounds.maxX || clampedY === bounds.minY || clampedY === bounds.maxY){
    triggerBounce();
    return;
  }

  no.style.transform = `translate(${clampedX}px,${clampedY}px)`;
}

actions.addEventListener("mousemove", e=>{
  const r = actions.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top + r.height/2;
  moveNo((cx - e.clientX)*0.9,(cy - e.clientY)*0.7, e);
});

actions.addEventListener("mouseleave", ()=>{
  no.style.transition = 'transform .35s ease';
  no.style.transform = 'translate(0,0)';
  setTimeout(()=> no.style.transition = 'transform .15s linear', 400);
});

actions.addEventListener("touchstart", e=>{
  const t = e.touches[0];
  const r = actions.getBoundingClientRect();
  // On touch devices, moveNo will be called for dragging, but taps should animate the button
  const isTap = e.touches.length === 1;
  if(isTap){
    // short delay to allow tap handler on the button itself to run
    const touch = e.touches[0];
    // If the touch started on the `no` button, play tap animation
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if(target === no || no.contains(target)){
      touchTapAnimate();
      return;
    }
  }
  moveNo((r.left - t.clientX)*.8,(r.top - t.clientY)*.6, t);
},{passive:true});

actions.addEventListener("touchend", ()=>{
  no.style.transition = 'transform .35s ease';
  no.style.transform = 'translate(0,0)';
  setTimeout(()=> no.style.transition = 'transform .15s linear', 400);
});

// If device supports touch, add a direct touch/click handler on the `no` button
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
if(isTouchDevice){
  no.addEventListener('click', (e)=>{
    // on touch devices, treat click as an intentional tap and animate
    touchTapAnimate();
    e.stopPropagation();
  });
}

yes.onclick = ()=> overlay.classList.add("show");
close.onclick = ()=> overlay.classList.remove("show");
overlay.onclick = e=> e.target===overlay && overlay.classList.remove("show");
</script>
</body>
</html>
